{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Embedded Systems II (13409)","text":""},{"location":"#course-description","title":"Course Description","text":"<p>This course develops practical competencies in advanced embedded communication and industrial connectivity using the ESP32-C6 and ESP-IDF/FreeRTOS. Students move from superloop firmware to RTOS-based, thread-safe architectures, emphasizing event-driven design, task scheduling, and safe peripheral access in concurrent systems. The course then focuses on modern IoT communication stacks: Wi-Fi (TCP/IP, HTTPS/REST, MQTT, WebSockets), Bluetooth Low Energy (GAP/GATT), and 802.15.4 mesh networking (Zigbee and Thread with Matter concepts), complemented by industrial protocols including TWAI (CAN) and Modbus TCP.</p>"},{"location":"#course-info","title":"Course Info","text":"<p>Instructor: Oliver Ochoa Garcia</p> <p>Contact: oliver.ochoa2@iberopuebla.mx</p> <p>Department: Department of Science and Engineering</p> <p>Credits: 8 </p> <p>Obligatory Pre-requisites: 13408 \"Embedded Systems 1\"</p>"},{"location":"Resources/","title":"Resources for class","text":"<p>Link to website template: Lab Log Template</p> <p>Link to Arithmatex tutorial: Arithmatex Tutorial</p>"},{"location":"M0_Fundamentals_and_Tools/T0_1/","title":"Syllabus","text":""},{"location":"M0_Fundamentals_and_Tools/T0_1/#course-meeting-times","title":"Course Meeting Times","text":"<p>Lectures: 2 sessions / week, 2 hours / session     - Tuesday, 17:00 - 19:00     - Thursday, 17:00 - 19:00</p>"},{"location":"M0_Fundamentals_and_Tools/T0_1/#prerequisites","title":"Prerequisites","text":"<ul> <li>Programming: C/C++ proficiency; basic Git (clone/commit/branch); comfortable reading vendor SDK examples.</li> <li>Embedded fundamentals: microcontrollers, GPIO/timers, interrupts, basic serial debugging.</li> <li>Electronics: prototyping, pull-ups, safe power practices, basic sensor interfacing.</li> <li>Buses: I2C experience is assumed (we focus on RTOS-safe access patterns and verification, not I2C basics).</li> <li>Tools readiness: laptop with VS Code, ESP-IDF toolchain capability, USB data cable(s) known-good, and ability to run Wireshark.</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_1/#course-text","title":"Course Text","text":"<ul> <li>ESP-IDF Programming Guide (ESP32-C6) and related API guides (Wi-Fi, MQTT examples, OTA, security, etc.).</li> <li>USB Serial/JTAG Console + JTAG Debugging (ESP32-C6).</li> <li>TWAI (CAN) driver documentation (ESP32-C6).</li> <li>ESP-NOW documentation (ESP32-C6).</li> <li>ESP Zigbee SDK (ESP32-C6).</li> <li>ESP-Matter (ESP32-C6) (Matter over Wi-Fi/Thread; commissioning via developer tooling).</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_1/#grading-policy","title":"Grading Policy","text":"<p>Grade Components:</p> Component What it covers Deliverables/Evidence Weight Lab Log (Web) All in-class practices, notes, and homework evidence across sessions Public web log with dated entries, code snippets, photos/videos, and reflections 40% 3-DOF Manipulator Project Mechanism, electronics, kinematics, trajectory generation, demo Demo video, repo (code + URDF/solid models), brief report, checklist 30% Ackermann Mobile Robot Project Perception, control, autonomy, trajectory tracking, demo Demo video, repo (ROS2 pkg + CAD/PCB), brief report, checklist 30% Total 100% <p>Grading scale</p> Raw Reported grade &lt; 5.00 5.0 5.00\u20135.99 5.0 6.00\u20136.89 6.0 6.90\u20136.99 7.0 7.00\u20137.79 7.0 7.80\u20137.99 8.0 8.00\u20138.69 8.0 8.70\u20138.99 9.0 9.00\u20139.59 9.0 9.60\u20139.99 10.0 10.00 10.0 <p>Late &amp; makeup policy</p> Item Policy Lab Log entries \u221210% of that entry per 24 h late, up to \u221250%; after 5 days = 0. Project milestones/demos \u221210% of that milestone per 24 h late; after 7 days = 0 unless documented emergency. Extensions Must be requested \u226524 h before deadline (once per project, up to 72 h). Regrade window Submit written request within 7 days of grade release. <p>Academic integrity &amp; collaboration</p> Item Policy Code/design reuse Allowed with citation; uncredited reuse = 0 on item. Collaboration Discuss concepts; submit your own code/designs. Shared repos between teams prohibited. <p>Communication &amp; submissions</p> Item Policy Platform Microsoft Teams is the official channel for announcements, deadlines, and grades. Content hosting All artifacts live on your Lab Log website. How to submit In each Teams assignment, submit the URL to the specific Lab Log entry (not the home page). Non-compliant submissions \u201cFiles only\u201d or missing/incorrect links = not submitted until corrected (late policy applies)."},{"location":"M0_Fundamentals_and_Tools/T0_1/#modules","title":"Modules","text":"Module Topics Readings M0 \u2014 Setup &amp; Evidence Culture ESP-IDF workflow, measurement habits, reproducible builds, debug hygiene ESP-IDF Programming Guide (Espressif Systems) M1 \u2014 RTOS &amp; Thread-Safe Embedded Design Tasks/queues, ISR-to-task patterns, shared resource protection, NVS config, low-power strategy ESP-IDF Guide + relevant examples (Espressif Systems) M2 \u2014 Wi-Fi Networking &amp; Telemetry Provisioning, SNTP, HTTPS REST, MQTT, WebSockets, fault injection + Wireshark evidence ESP-IDF Guide (Wi-Fi + networking) (Espressif Systems) M3 \u2014 BLE for Control &amp; Sensing GAP/advertising, GATT services, phone-based validation, basic security posture ESP-IDF Guide (BLE sections) (Espressif Systems) M4 \u2014 Industrial &amp; Mesh TWAI (CAN), ESP-NOW, Zigbee, Thread, Matter concepts + commissioning logs TWAI (Espressif Systems); ESP-NOW (Espressif Systems); Zigbee SDK (Espressif Systems); ESP-Matter (Espressif Systems) M5 \u2014 Production Readiness USB Serial/JTAG debug workflow, security concepts, OTA, coexistence/integration, watchdogs + crash forensics USB Serial/JTAG + JTAG Debugging (Espressif Systems); ESP-Matter (commissioning guidance) (Espressif Systems)"},{"location":"M0_Fundamentals_and_Tools/T0_1/#calendar-sessions","title":"Calendar Sessions","text":"S Module Date Topic Deliverable 1 M0 2026-01-20 ESP32-C6 vs RP2040 + ESP-IDF workflow Lab Log: build/flash/monitor proof + repo initialized 2 M1 2026-01-22 FreeRTOS I: scheduler, priorities, timing evidence Lab Log: 3-task demo + timing screenshots 3 M1 2026-01-27 FreeRTOS II: thread-safe peripheral pattern (I2C gatekeeper) Lab Log: gatekeeper API + collision-free evidence 4 M1 2026-01-29 ISR\u2192Queue\u2192Task (UART console) Lab Log: non-blocking console + 5 commands 5 M1 2026-02-03 NVS for config + provisioning state Lab Log: persistent keys + reboot proof 6 M1 2026-02-05 Low-power architecture (measure + improve) Lab Log: current measurement method + improvement summary 7 M2 2026-02-10 Wi-Fi STA + provisioning (SoftAP base path) Lab Log: provisioning flow + Wireshark DHCP/DNS 8 M2 2026-02-12 SNTP time sync + scheduling Lab Log: correct timestamps + drift notes 9 M2 2026-02-17 HTTPS REST client: retries/timeouts + evidence Lab Log: POST JSON + success/failure captures 10 M2 2026-02-19 MQTT fundamentals (broker, topics, QoS) Lab Log: pub/sub between nodes + topic design 11 M2 2026-02-24 MQTT advanced: LWT + JSON control Lab Log: LWT power-cut proof + cJSON parsing 12 M2 2026-02-26 WebSockets vs MQTT streaming (latency/jitter) Lab Log: 20 Hz stream + comparison table 13 M2 2026-03-03 Midterm Sprint I: architecture + state machine Lab Log: task diagram + failure modes list 14 M2 2026-03-05 Midterm Sprint II: fault injection + recovery Lab Log: router-unplug recovery evidence 15 M2 2026-03-10 MIDTERM EVALUATION: Wireless Sensor Node demo Demo + repo tag + checklist submission 16 M4 2026-03-12 TWAI (CAN) I: frames + transceiver bring-up Lab Log: send/receive frames + evidence 17 M4 2026-03-17 TWAI (CAN) II: filters + error handling Lab Log: bus-off/recovery notes + test 18 M4 2026-03-19 ESP-NOW: low-latency swarm sync Lab Log: \u22653 nodes + measured latency 19 M3 2026-03-24 BLE GAP + advertising strategy Lab Log: dynamic advertising proof (phone app) 20 M3 2026-03-26 BLE GATT server for control/telemetry Lab Log: custom service + characteristics proof \u2014 \u2014 2026-03-31 NO CLASS \u2014 suspension/vacations \u2014 (iberopuebla.mx) \u2014 \u2014 2026-04-02 NO CLASS \u2014 suspension/vacations \u2014 (iberopuebla.mx) 21 M4 2026-04-07 Zigbee fundamentals: roles + network formation Lab Log: join + messaging evidence 22 M4 2026-04-09 Zigbee binding/clusters (applied control) Lab Log: switch\u2192light via binding proof 23 M4 2026-04-14 Thread fundamentals: IPv6 + UDP across mesh Lab Log: UDP messages + addressing proof 24 M4 2026-04-16 Matter concepts + commissioning (developer tooling) Lab Log: commissioning logs + interpretation 25 M4 2026-04-28 Modbus TCP: industrial interoperability Lab Log: register map + PC master proof 26 M5 2026-04-30 USB Serial/JTAG workflow + JTAG debugging basics Lab Log: flash/monitor via native USB evidence (Espressif Systems) \u2014 \u2014 2026-05-05 NO CLASS \u2014 mandatory holiday \u2014 (iberopuebla.mx) 27 M5 2026-05-07 Security I: threat model + protected storage demo Lab Log: security checklist + demo evidence 28 M5 2026-05-08 Lab Clinic (mandatory): integration help + backlog burn-down Updated Lab Log: resolved issues + test reruns 29 M5 2026-05-12 Security II: certificates + mTLS (secure MQTT) Lab Log: handshake success + failure case 30 M5 2026-05-14 OTA updates + rollback strategy Lab Log: OTA success + forced rollback proof 31 M5 2026-05-19 Final sprint: coexistence + watchdogs + crash forensics Lab Log: backtrace analysis + fix/mitigation 32 M5 2026-05-21 FINAL EXPO: Multiprotocol Gateway / Industrial IoT demo Live demo + final portfolio + repo tag"},{"location":"M0_Fundamentals_and_Tools/T0_2/","title":"Session N \u2014 Short Title","text":"<p>One-sentence purpose of the session.</p> <p>Use when: Every entry; this is the canonical title and brief purpose. Skip when: Never.</p>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li> Implement ______ (e.g., ROS2 node publishing joint states)</li> <li> Validate ______ (e.g., Ackermann kinematics constraint)</li> <li> Document ______ (e.g., BOM with costs, wiring diagram) <p>Use when: Always, to define the goals of the activity; mark as checkboxes and evaluate at the end. Skip when: Never</p> </li> </ul>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#2-materials-setup","title":"2) Materials &amp; Setup","text":"<p>BOM (bill of materials)</p> # Item Qty Link/Source Cost (MXN) Notes 1 ______ __ ______ __ ______ <p>Tools/Software - OS/Env: Ubuntu 24.04 + ROS 2 Jazzy (WSL2 ok) - Editors: VS Code, Python 3.12, Arduino IDE, RoboDK (if used) - Slicers/ECAD: PrusaSlicer, Altium, Multisim</p> <p>Wiring / Safety - Motor driver current limit: __ A (\u2264 spec) - Battery: LiPo __S, follow charging protocol - PPE / Risk notes: ______</p> <p>Use when: Hardware or software setup affects reproducibility or safety; include current limits and battery notes. Skip when: Pure software simulation with no hardware or safety changes; still list software versions briefly.</p>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#3-procedure-what-you-did","title":"3) Procedure (what you did)","text":"<ol> <li>Step 1: Concise action with command(s)    <pre><code># Example: build ROS workspace\ncolcon build --symlink-install\nsource install/setup.bash\n</code></pre></li> <li>Step 2: Screenshots/console logs as needed</li> <li>Step 3: Verification checkpoint \u2705 <p>Use when: Documenting steps so another student can reproduce results from a clean state. Skip when: Only design discussion or planning occurred; move notes to Reflection and Analysis.</p> </li> </ol>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#4-data-tests-evidence","title":"4) Data, Tests &amp; Evidence","text":"<p>Test plan - Inputs: __ - Expected: ____ - Metrics: RMSE, latency, current draw, etc.</p> <p>Results <pre><code># Paste concise logs or metrics\nmean_error = 2.3 deg\nlatency_ms = 14.8\n</code></pre></p> <p>Tables/plots | Case | Input | Output | Error | Pass? | |------|-------|--------|-------|-------| | A | \u2026 | \u2026 | \u2026 | \u2705/\u274c |</p> <p>Use when: You measured, tested, or compared against expected behavior; include raw evidence and brief summaries. Skip when: Nothing was executed; defer to Procedure or Reflection.</p>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#5-analysis","title":"5) Analysis","text":"<ul> <li>Compare expected vs observed.  </li> <li>Explain anomalies (friction, backlash, sampling, clipping).  </li> <li> <p>Link to equations/constraints (e.g., Pfaffian for nonholonomic: A(q)\u00b7q_dot = 0).  Equations should be in a readable format (LaTeX or code). For example:   $$   A(q) \\cdot \\dot{q} = 0   $$</p> </li> <li> <p>Propose fixes (calibration, PID gains, step timing).</p> <p>Use when: Data exists or you made claims that require justification; tie to theory. Skip when: Session only set up infrastructure with no results; provide a short note and defer deeper analysis to a later entry.</p> </li> </ul>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#6-code","title":"6) Code","text":"<p>Short, runnable snippets only. Link big files to repo.</p> <p><pre><code># Example: publish joint states\n# SAFETY: respect joint limits before publishing\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n</code></pre> <pre><code>// Example: Arduino motor test (watch current &amp; temperature)\n</code></pre></p> <p>Use when: A snippet clarifies the approach, parameters, or API usage; keep it executable and minimal. Skip when: Code is long; link to repository paths and commits instead.</p>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_2/#7-files-media","title":"7) Files &amp; Media","text":"<ul> <li>CAD/URDF: /urdf/arm_3dof.urdf.xacro</li> <li>Launch: /launch/sim.launch.py</li> <li>Firmware: /firmware/drive_test/</li> <li>Video demo (\u226460 s): https://\u2026  </li> <li>Photos: img/sessionN_* <p>Use when: Artifacts help a reviewer verify function or build the same setup. Skip when: No media or files were changed; omit to keep the entry concise.</p> </li> </ul>","tags":["sessionN","manipulator","ackermann","ros2","arduino"]},{"location":"M0_Fundamentals_and_Tools/T0_3/","title":"ESP-IDF Workflow","text":""},{"location":"M0_Fundamentals_and_Tools/T0_3/#context","title":"Context","text":"Feature ESP32-C6 RP2040 Why it matters in this course CPU 32-bit RISC-V (single core) Dual-core Arm Cortex-M0+ C6 targets wireless + low-power IoT; RP2040 targets deterministic MCU tasks Wi-Fi Yes (2.4 GHz) No Course focus includes HTTP/MQTT and security Bluetooth LE Yes (BLE 5) No We will do GATT/advertising + mobile interaction Zigbee / Thread Yes (802.15.4 radio) No Enables Zigbee/Thread and path to Matter Matter Feasible on C6 (via Thread/Wi-Fi stacks) Not natively Final project: multiprotocol gateway/IIoT USB USB Serial/JTAG (device) on many C6 DevKits USB device support depends on board/SDK; common via PIO/SDK Impacts flashing, logging, and debugging experience PIO (Programmable I/O) No direct equivalent Yes (PIO is a signature feature) RP2040 shines for custom waveforms/protocol emulation Low-power IoT Strong deep-sleep + radio power mgmt Low-power possible but no radio Our labs emphasize deep sleep + secure comms Ecosystem ESP-IDF, Espressif stacks Pico SDK / Arduino / RTOS options We standardize on ESP-IDF for professional IoT workflows <ul> <li>Choose ESP32-C6 when you need: Wi-Fi, BLE, Zigbee/Thread, Matter path, and integrated security + provisioning.</li> <li>Choose RP2040 when you need: tight timing, PIO-based custom protocols, or as a co-processor for specialized I/O.</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#toolchain-philosophy-why-esp-idf","title":"Toolchain Philosophy: Why ESP-IDF","text":"<p>ESP-IDF is Espressif\u2019s official framework: - Native access to Wi-Fi/BLE/802.15.4 stacks, FreeRTOS, NVS, security primitives. - Production-grade build system (CMake + Ninja), component model, menu configuration, and logging. - Better alignment with debugging, provisioning, certificates, OTA, and power management.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#esp-idf-workflow_1","title":"ESP-IDF Workflow","text":""},{"location":"M0_Fundamentals_and_Tools/T0_3/#repository-layout-recommended","title":"Repository Layout (Recommended)","text":"<pre><code>project-root/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 sdkconfig.defaults\n\u251c\u2500\u2500 main/\n\u2502   \u251c\u2500\u2500 CMakeLists.txt\n\u2502   \u2514\u2500\u2500 app_main.c\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 my_driver/\n\u2502       \u251c\u2500\u2500 CMakeLists.txt\n\u2502       \u251c\u2500\u2500 include/\n\u2502       \u2514\u2500\u2500 my_driver.c\n\u2514\u2500\u2500 docs/\n    \u2514\u2500\u2500 logbook.md\n</code></pre>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#core-commands","title":"Core Commands","text":"<p>From the project root:</p> <ol> <li>Set target (once per project)</li> <li>Set target (once per project)</li> <li><code>idf.py set-target esp32c6</code></li> <li>Configure (as needed)</li> <li><code>idf.py menuconfig</code></li> <li>Build</li> <li><code>idf.py build</code></li> <li>Flash</li> <li><code>idf.py -p PORT flash</code></li> <li>Example: <code>idf.py -p /dev/ttyACM0 flash</code></li> <li>Monitor logs</li> <li><code>idf.py -p PORT monitor</code></li> <li>Tip: You can combine them: <code>idf.py -p PORT flash monitor</code></li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#usb-on-esp32-c6-what-you-need-to-know","title":"USB on ESP32-C6: What You Need to Know","text":""},{"location":"M0_Fundamentals_and_Tools/T0_3/#usb-serialjtag-vs-classic-uart","title":"USB-Serial/JTAG vs \u201cClassic UART\u201d","text":"<p>Many ESP32-C6 DevKits expose a USB port that supports: - USB Serial (console logging / flashing) - USB JTAG (debugging)</p> <p>This differs from classic external USB-to-UART bridges (CP2102/CH340) used on older boards.</p> <p>Practical impact - The same USB cable can provide flashing + logs + debugging (board dependent). - Port enumeration can change between OSes\u2014document your <code>&lt;PORT&gt;</code>.</p> <p>If flashing works but monitoring doesn\u2019t (or vice versa), verify: - Correct port selected - Menuconfig USB console settings (project-dependent) - Cable quality (data vs charge-only)</p>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#networking-security-implications","title":"Networking &amp; Security Implications","text":""},{"location":"M0_Fundamentals_and_Tools/T0_3/#wi-fi-httpmqtt","title":"Wi-Fi (HTTP/MQTT)","text":"<p>You will implement: - Station + Access Point basics - HTTP client/server patterns - MQTT pub/sub with authentication - TLS fundamentals (certs, time, root CA)</p>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#ble","title":"BLE","text":"<p>You will implement: - Advertising vs connections - GATT services/characteristics - Mobile interaction testing (e.g., generic BLE scanner apps) - Security modes and pairing considerations</p>"},{"location":"M0_Fundamentals_and_Tools/T0_3/#zigbeethread-matter","title":"Zigbee/Thread \u2192 Matter","text":"<p>You will explore: - 802.15.4 fundamentals (channels, PAN IDs) - Thread concepts (mesh, border router role) - Matter at a high level (commissioning, multi-admin, device models)</p>  In progress -&gt;"},{"location":"M0_Fundamentals_and_Tools/T0_4/","title":"RTOS Introduction","text":""},{"location":"M0_Fundamentals_and_Tools/T0_4/#hard-vs-soft-real-time","title":"Hard vs Soft Real-Time","text":"<ul> <li>Hard real-time: Missing a deadline is a system failure (e.g., airbag deployment).</li> <li>Soft real-time: Deadlines matter, but occasional misses degrade performance rather than cause failure (e.g., audio buffering).</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#overview-of-programming-models","title":"Overview of Programming Models","text":"<p>Embedded systems programming often uses two main models.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#superloop-definition","title":"Superloop Definition","text":"<p>A superloop is a common bare-metal firmware structure where the program runs an infinite <code>while(1)</code> loop (\u201cmain loop\u201d). It repeatedly calls functions to handle tasks\u2014like reading inputs, updating outputs, and running state machines\u2014often using interrupts to handle urgent events.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#rtos-definition","title":"RTOS Definition","text":"<p>A Real-Time Operating System (RTOS) is a lightweight operating system designed to run applications where timing matters. Unlike general-purpose OSes (PC/phone), an RTOS focuses on predictable response times so the system can react to events within known deadlines.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#comparison-superloop-vs-rtos","title":"Comparison: Superloop vs. RTOS","text":"Feature Superloop RTOS Execution Model One main loop runs everything in a fixed/semi-fixed order. Multiple tasks/threads run under a scheduler (priority-based). Responsiveness Depends on loop length; long operations delay everything. High; priorities and preemption ensure urgent tasks run quickly. Complexity Simple to start; gets messy as features grow (flags, spaghetti code). Higher upfront complexity; scales better for large systems. Determinism Deterministic if strictly timed (no blocking) and ISRs are bounded. Supports deterministic behavior when ISR time, priorities, and shared resources are engineered correctly. Resource Usage Minimal overhead (fewer stacks, no scheduler). Higher RAM/Flash usage (task stacks, TCBs, context switching). Synchronization Manual (globals, flags, ring buffers). Built-in primitives (Queues, Semaphores, Mutexes). Best Fit Small/simple products, tight memory constraints. Complex systems, multiple concurrent protocols, modular design."},{"location":"M0_Fundamentals_and_Tools/T0_4/#why-use-an-rtos","title":"Why use an RTOS?","text":"<p>In embedded systems, you often need to handle multiple things \u201cat once,\u201d such as: * Reading sensors * Driving motors or actuators * Managing communication (UART/I2C/SPI/CAN/Ethernet) * Updating a UI or logging data</p> <p>An RTOS helps you structure this cleanly by splitting work into Tasks and letting the scheduler decide who runs when.</p> <p>Engineering judgement: If a system is small, timing is simple, and RAM is tight, a well-structured superloop may be the better choice.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#core-ideas-of-an-rtos","title":"Core Ideas of an RTOS","text":""},{"location":"M0_Fundamentals_and_Tools/T0_4/#1-tasks-threads","title":"1. Tasks (Threads)","text":"<p>Independent functions that run \u201cconcurrently\u201d via scheduling. * Note: Time slicing (round-robin) is typically optional and usually applies only among tasks of equal priority when enabled. * Example:     * <code>SensorTask</code>: reads IMU every 10 ms     * <code>ControlTask</code>: runs PID at 1 kHz     * <code>CommsTask</code>: sends telemetry at 50 Hz</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#2-scheduler","title":"2. Scheduler","text":"<p>The kernel component that chooses the next task to run, usually based on priority. * Example:     * <code>ControlTask</code> has higher priority than <code>LoggingTask</code>.     * If <code>ControlTask</code> becomes ready, it can preempt <code>LoggingTask</code> immediately (in a preemptive configuration).</p> <p>Timing note: Real-time behavior depends on tick rate, ISR latency, and how long interrupts/critical sections block scheduling.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#3-context-switch","title":"3. Context Switch","text":"<p>The action of saving the current task\u2019s CPU state (registers, stack pointer) and restoring another\u2019s so the CPU can run a different task. * Example:     * A low-priority task is running. An interrupt wakes a high-priority task \u2192 the RTOS saves the low-priority context and switches to the high-priority one.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#4-blocking-vs-non-blocking","title":"4. Blocking vs. Non-blocking","text":"<p>Tasks can wait (block) for events/resources or run without waiting. * Example:     * <code>SensorTask</code> blocks (sleeps) for ~10 ms using <code>vTaskDelay(pdMS_TO_TICKS(10))</code> (tick rate dependent).     * <code>CommsTask</code> runs periodically to check a buffer (polling).</p> <p>Design pitfall: A high-priority task that never blocks/yields can starve lower-priority work.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#5-inter-task-communication-queues","title":"5. Inter-task Communication (Queues)","text":"<p>Thread-safe mechanisms to pass data between tasks, typically in FIFO order. * Example: <code>SensorTask</code> sends measurements to <code>ControlTask</code> via a queue.     * Producer: Puts <code>{temp, accel, gyro}</code> into queue.     * Consumer: Pops the next sample in FIFO order.</p> <p>\u201cLatest value\u201d pattern: If you want the consumer to always use the most recent value (not FIFO history), consider a length-1 queue with overwrite, a shared struct + mutex, or task notifications (depending on your RTOS).</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#6-semaphores-mutexes","title":"6. Semaphores &amp; Mutexes","text":"<p>Synchronization objects used to signal events or manage access to limited resources.</p> <ul> <li>Binary Semaphore: Signals \"something happened\" (0/1).<ul> <li>Example: An ISR gives a semaphore when a UART packet arrives; <code>CommsTask</code> takes it to process data. (FreeRTOS pattern: <code>xSemaphoreGiveFromISR()</code> in ISR, <code>xSemaphoreTake()</code> in task.)</li> </ul> </li> <li>Counting Semaphore: Tracks multiple identical resources.<ul> <li>Example: Counting slots in a buffer pool.</li> </ul> </li> <li>Mutex: Protects a shared resource (like an I2C bus) from being accessed by two tasks simultaneously.<ul> <li>Note: Many RTOSes (including FreeRTOS) support priority inheritance with mutexes, helping reduce priority inversion.</li> </ul> </li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#task-states","title":"Task States","text":"<p>At any given time, a task is in one of the following states:</p> <ol> <li> <p>Running</p> <ul> <li>Definition: The task is currently executing on the CPU.</li> <li>Example: <code>ControlTask</code> is calculating PWM duty cycle.</li> </ul> </li> <li> <p>Ready</p> <ul> <li>Definition: The task is able to run immediately but is waiting for the CPU (because another Ready task is currently running\u2014often a higher priority task, or a same-priority task depending on time slicing).</li> <li>Example: <code>CommsTask</code> has data to send, but <code>ControlTask</code> is currently using the CPU.</li> </ul> </li> <li> <p>Blocked</p> <ul> <li>Definition: The task is waiting for an event (time, data, semaphore) and cannot run until that event occurs.</li> <li>Example: <code>SensorTask</code> is sleeping for ~10 ms via <code>vTaskDelay(pdMS_TO_TICKS(10))</code>.</li> </ul> </li> <li> <p>Suspended</p> <ul> <li>Definition: Explicitly taken out of scheduling; will not run until explicitly resumed.</li> <li>Example: <code>LoggingTask</code> is suspended to prevent flash writes during a critical motor startup phase.</li> </ul> </li> <li> <p>Deleted</p> <ul> <li>Definition: The task has been removed from the kernel; its resources are freed.</li> </ul> </li> </ol> <p> </p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#scheduling-and-priorities","title":"Scheduling and Priorities","text":"<p>The scheduler decides which Ready task runs. Most embedded RTOSes use Preemptive Priority-Based Scheduling:</p> <p>Rule: The highest-priority Ready task always runs. Lower-priority tasks run only when higher ones are Blocked, Suspended, or Deleted.</p> <p>If multiple tasks share the highest Ready priority, the scheduler selects among them (often round-robin if time slicing is enabled).</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#preemptive-vs-cooperative","title":"Preemptive vs. Cooperative","text":"<ul> <li>Preemptive (Standard): A high-priority task can interrupt a low-priority task immediately when it becomes Ready.</li> <li>Cooperative: Tasks run until they voluntarily yield or block. Simpler, but easier to hang the system.</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#how-to-choose-priorities","title":"How to Choose Priorities","text":"<p>Assign priorities based on deadline strictness and failure consequences:</p> <ol> <li>High (Safety / Hard Deadlines): Motor control, protection loops, watchdog checks.</li> <li>Medium-High (Real-time I/O): Draining UART/SPI buffers, handling packets.</li> <li>Medium (App Logic): Parsing, decision making, state machines.</li> <li>Low (Background): Logging, UI updates, debug printing.</li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#activities","title":"Activities","text":""},{"location":"M0_Fundamentals_and_Tools/T0_4/#exercise-objective","title":"Exercise Objective","text":"<p>The goal of this exercise is to train you to identify logical FreeRTOS tasks from system behavior, even when no RTOS code is shown.</p> <p>You should focus on:</p> <ul> <li>Timing requirements</li> <li>Blocking behavior</li> <li>Safety and criticality</li> <li>Independent execution flows</li> </ul> <p>Think in terms of \"what must happen independently\", not functions or lines of code.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#system-description","title":"System Description","text":"<p>You are given the following description of an embedded system:</p> <p>The system:</p> <ul> <li>Reads a temperature sensor every 50 ms</li> <li>Sends sensor data via Wi-Fi every 2 seconds</li> <li>Monitors an emergency button continuously</li> <li>Blinks a status LED at 1 Hz</li> <li>Stores error messages when failures occur</li> </ul> <p>Assume:</p> <ul> <li>The system runs on a microcontroller</li> <li>Timing matters</li> <li>Some operations may block (Wi-Fi, storage)</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#exercise-1-identify-logical-tasks","title":"Exercise 1 \u2014 Identify Logical Tasks","text":"<p>List the logical tasks that exist in this system.</p> <p>Do not think about code yet \u2014 think about behavior.</p> Task Name (Your Choice) Trigger (Time / Event) Periodic or Event-Based"},{"location":"M0_Fundamentals_and_Tools/T0_4/#exercise-2-task-characteristics","title":"Exercise 2 \u2014 Task Characteristics","text":"<p>For each task you identified, answer the following:</p> <ul> <li>Is it time-critical? (Yes / No)</li> <li>Can it block safely? (Yes / No)</li> <li>What happens if this task is delayed?</li> </ul> <p>Write short, technical answers.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#exercise-3-priority-reasoning","title":"Exercise 3 \u2014 Priority Reasoning","text":"<p>Assign a relative priority to each task:</p> <ul> <li>High</li> <li>Medium</li> <li>Low</li> </ul> <p>Then justify each choice in one sentence.</p> Task Name Priority (H/M/L) Justification"},{"location":"M0_Fundamentals_and_Tools/T0_4/#exercise-4-design-judgment-trick-question","title":"Exercise 4 \u2014 Design Judgment (Trick Question)","text":"<p>Which of the following should NOT necessarily be implemented as a FreeRTOS task?</p> <ul> <li>Emergency button monitoring</li> <li>Wi-Fi transmission</li> <li>Error logging</li> <li>Status LED blinking</li> </ul> <p>Explain why in 2\u20133 sentences.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#exercise-5-identifying-hidden-tasks-in-pseudo-code","title":"Exercise 5 \u2014 Identifying Hidden Tasks in Pseudo-Code","text":"<p>The following pseudo-code represents a single-loop embedded program written without an RTOS.</p> <pre><code>while (1) {\n    read_temperature_sensor();          // takes ~2 ms\n\n    if (button_pressed()) {\n        emergency_shutdown();            // must react immediately\n    }\n\n    if (time_since_last_send() &gt; 2000) {\n        send_data_over_wifi();            // may block for 100\u2013300 ms\n    }\n\n    toggle_status_led();                 // 1 Hz blink rate\n\n    delay_ms(10);\n}\n</code></pre>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#task-51-identify-hidden-tasks","title":"Task 5.1 \u2014 Identify Hidden Tasks","text":"<p>Even though this code uses a single <code>while(1)</code> loop, multiple logical tasks are hidden inside it.</p> <p>List the tasks you can identify.</p> Hidden Task Trigger (Time / Event) Why it should be a Task"},{"location":"M0_Fundamentals_and_Tools/T0_4/#task-52-blocking-analysis","title":"Task 5.2 \u2014 Blocking Analysis","text":"<p>Answer the following:</p> <ol> <li>Which function can block the CPU?</li> <li>What other behaviors are affected while it blocks?</li> <li>Which hidden task is most at risk because of this blocking?</li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#task-53-rtos-refactoring-thought-experiment","title":"Task 5.3 \u2014 RTOS Refactoring Thought Experiment","text":"<p>Without writing code:</p> <ol> <li>Which hidden task(s) should become FreeRTOS tasks?</li> <li>Which behavior(s) should be handled using an interrupt?</li> <li>Which task should have the highest priority, and why?</li> </ol> <p>Write short, technical justifications.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_4/#submission-instructions","title":"Submission Instructions","text":"<ul> <li>Complete individually</li> <li>Be prepared to justify your answers orally</li> <li>No single correct solution \u2014 logic and justification matter</li> </ul> &lt;- Workflow In progress -&gt;"},{"location":"M0_Fundamentals_and_Tools/T0_5/","title":"RTOS Basics with ESP-IDF LAB","text":""},{"location":"M0_Fundamentals_and_Tools/T0_5/#what-you-will-learn","title":"What you will learn","text":"<p>By the end, you should be able to:</p> <ul> <li>Create multiple FreeRTOS tasks in ESP-IDF.</li> <li>Use blocking correctly (<code>vTaskDelay</code>, waiting on a queue/mutex) so tasks don\u2019t hog the CPU.</li> <li>Pass data between tasks using a queue (producer/consumer pattern).</li> <li>Protect shared resources using a mutex (avoid race conditions).</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#setup","title":"Setup","text":"<ol> <li>Create a new ESP-IDF project (or use your template).</li> <li>Put the lab code into <code>main/main.c</code>.</li> <li>Build/flash/monitor using your normal workflow, e.g.:</li> <li><code>idf.py build flash monitor</code></li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#hardware-note-led-pin","title":"Hardware note: LED pin","text":"<p>The built-in LED GPIO differs by board. In the examples below we use:</p> <pre><code>#define LED_GPIO GPIO_NUM_2\n</code></pre> <p>If your board\u2019s LED is not GPIO2, change it to match your wiring.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#lab-1-two-tasks-delays-priorities","title":"Lab 1 \u2014 Two tasks, delays, priorities","text":""},{"location":"M0_Fundamentals_and_Tools/T0_5/#goal","title":"Goal","text":"<p>Create two tasks:</p> <ul> <li>blink_task: toggles an LED every 300 ms</li> <li>hello_task: prints a message every 1 second</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#what-to-watch-for","title":"What to watch for","text":"<ul> <li>Both tasks run (interleave).</li> <li>Changing priority can change which task runs \u201cmore\u201d or \u201cfirst\u201d.</li> <li>If you remove a delay from a task, it may hog the CPU.</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#syntax-used","title":"Syntax used","text":"<ul> <li><code>TAG</code> is just a label string used by ESP-IDF logging so you can see where the message came from.</li> <li><code>vTaskDelay()</code> is a FreeRTOS function that suspends the calling task for a specified number of system ticks, placing it into a blocked state. It is a non-blocking (to the CPU) delay, allowing other tasks to run. </li> <li><code>pdMS_TO_TICKS(n)</code> converts milliseconds to system ticks, which is the unit FreeRTOS uses for timing. <pre><code>vTaskDelay(pdMS_TO_TICKS(300));\n</code></pre></li> <li><code>ESP_LOGI(const char* tag, const char* format, ...)</code> is an ESP-IDF logging function that logs an informational message. The <code>tag</code> parameter helps identify the source of the log message, and the <code>format</code> parameter allows for formatted output similar to <code>printf</code>, the <code>...</code> are variadic argumentsVariables to be replaced into the format string, matching the format specifiers. </li> <li><code>ESP_LOGW(const char* tag, const char* format, ...)</code>Used when something unexpected happens but the program can continue (like queue full) so it's a warning. <pre><code>ESP_LOGI(TAG, \"Produced %d\", value);\nESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n</code></pre> <code>xTaskCreate()</code> creates a new FreeRTOS task. It takes the following parameters: <pre><code>BaseType_t xTaskCreate(\n    TaskFunction_t pvTaskCode,  //  A pointer to the function that implements the task.\n    const char * const pcName,  //  A descriptive name for the task, primarily used for debugging purposes\n    const uint32_t usStackDepth,//  The size of the stack allocated for the task, specified in words, not bytes.\n    void *pvParameters,         //   A value, typically a pointer to a variable or structure, that is passed as a parameter to the created task's function.\n    UBaseType_t uxPriority,     //  The priority at which the task should run, with 0 being the lowest priority. \n    TaskHandle_t *pxCreatedTask //  Used to pass back a handle by which the created task can be referenced and manipulated by other API\n);\n\n/* EXAMPLE */\n\nxTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n</code></pre></li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#code-lab-1","title":"Code (Lab 1)","text":"<p>Copy into <code>main/main.c</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#exercises","title":"Exercises","text":"<ol> <li>Priority experiment: change <code>hello_task</code> priority from <code>5</code> to <code>2</code>.  </li> <li>Does behavior change? Why might it (or might it not)?</li> <li>Starvation demo: temporarily remove <code>vTaskDelay(...)</code> from <code>hello_task</code>.  </li> <li>What happens to blinking?  </li> <li>Put the delay back and explain in one sentence why blocking helps.</li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#lab-2-queue-producerconsumer","title":"Lab 2 \u2014 Queue: producer/consumer","text":""},{"location":"M0_Fundamentals_and_Tools/T0_5/#goal_1","title":"Goal","text":"<p>Use a queue to pass integers from a producer task to a consumer task.</p> <p>Why it matters: - Queues are a clean way to pass data without sharing global variables.</p> <p>Note</p> <p>Remember MUTEX means Mutual EXclusion (protect shared resources), while QUEUE is for passing data between tasks.It operates like a binary flag, indicating whether the resource is locked (0) or unlocked (1).</p>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#syntax","title":"Syntax","text":"<ul> <li><code>xQueueCreate(num_items, item_size)</code> creates a new queue. Where num_items is the maximum number of items the queue can hold, and item_size is the size (in bytes) of each item. <pre><code>q_numbers = xQueueCreate(5, sizeof(int));\n</code></pre></li> <li><code>xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50))</code> sends an item to the back of the queue. Where <code>q_numbers</code> is the handle of the queue(which queue), <code>&amp;value</code> is a pointer to the item to be sent, and <code>pdMS_TO_TICKS(50)</code> is the maximum time to wait if the queue is full. It returns pdPASS if successful.</li> <li><code>xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000));</code> receives an item from the front of the queue. Where <code>q_numbers</code> is the handle of the queue(which queue), <code>&amp;rx</code> is a pointer to the variable where the received item will be stored, and <code>pdMS_TO_TICKS(1000)</code> is the maximum time to wait if the queue is empty. It returns pdPASS if successful.</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#code-lab-2","title":"Code (Lab 2)","text":"<p>Replace <code>main/main.c</code> with:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#exercises_1","title":"Exercises","text":"<ol> <li>Make the producer faster: change producer delay <code>200ms \u2192 20ms</code>.</li> <li>When do you see \u201cQueue full\u201d?</li> <li>Increase the queue length <code>5 \u2192 20</code>.</li> <li>What changes?</li> <li>Make the consumer \u201cslow\u201d: after a successful receive, add:    <pre><code>vTaskDelay(pdMS_TO_TICKS(300));\n</code></pre></li> <li>What pattern is happening now (buffering / backlog)?</li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#lab-3-mutex-protect-a-shared-resource","title":"Lab 3 \u2014 Mutex: protect a shared resource","text":""},{"location":"M0_Fundamentals_and_Tools/T0_5/#goal_2","title":"Goal","text":"<p>See a race condition happen with a shared counter, then fix it with a mutex.</p>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#syntax_1","title":"Syntax","text":"<ul> <li><code>xSemaphoreCreateMutex()</code> creates a new mutex. It returns a handle to the created mutex.</li> <li><code>xSemaphoreTake(mutex, portMAX_DELAY)</code> attempts to take (lock) the mutex. If the mutex is already taken by another task, the calling task will block indefinitely (due to <code>portMAX_DELAY</code>) until the mutex becomes available.</li> <li><code>xSemaphoreGive(mutex)</code> releases (unlocks) the mutex, allowing other tasks to take it.</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#part-a-race-demo-no-mutex","title":"Part A \u2014 Race demo (no mutex)","text":"<p>Replace <code>main/main.c</code> with:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> <p>why can the counter be wrong?  </p>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#part-b-fix-with-a-mutex","title":"Part B \u2014 Fix with a mutex","text":"<p>Replace with:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#exercises_2","title":"Exercises","text":"<ol> <li>Remove the mutex again. Do you ever see weird behavior?  </li> <li>Change priorities: TaskA priority <code>6</code>, TaskB priority <code>4</code>.  </li> <li>What do you expect and why?</li> <li>In one sentence: what does a mutex \u201cguarantee\u201d?</li> </ol>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#wrap-up-what-to-use-when","title":"Wrap-up: what to use when","text":""},{"location":"M0_Fundamentals_and_Tools/T0_5/#rule-of-thumb","title":"Rule of thumb","text":"<ul> <li>Periodic work (blink, poll, print): use a task + <code>vTaskDelay(pdMS_TO_TICKS(x))</code></li> <li>Data passing between tasks: use a queue</li> <li>Shared resource (shared variable, shared peripheral access): use a mutex</li> </ul>"},{"location":"M0_Fundamentals_and_Tools/T0_5/#extra-mini-challenges","title":"Extra mini-challenges","text":"<ol> <li>Heartbeat + work task</li> <li>Add a third task that prints \u201calive\u201d every 2 seconds.</li> <li>Queue with struct</li> <li>Send a struct: <code>{int id; int value;}</code></li> <li>Mutex around a shared peripheral</li> <li>Make two tasks write to the same log message format (simulate \u201cshared UART resource\u201d) and guard it with a mutex.</li> </ol>"}]}